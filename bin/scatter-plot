#!/usr/bin/env ruby
require 'trollop'
require 'mkmf'

DATA_FILE_NAME="/tmp/plot-"+`date  "+%s"`.strip+".dat"
PLOT_FILE_NAME="/tmp/plot-"+`date  "+%s"`.strip+".plt"


@opts = Trollop::options do
    banner "scatter-plot takes whitespace separated tables from stdin and renders them using gnuplot"
    opt :outfile, "Output file name", :type => String, :short => 'o'
    opt :legends, "Legend for columns, pipe separated list", :type => String, :short => 'l'
    opt :plot_styles, "Style of plot, comma separated list, values as expected by gnuplot, e.g. lines, points, linespoints, defaults to points", :type => String
    opt :axis_labels,  "Labels for axes, pipe separated list", :type => String
    opt :axes,  "Axes used for the respective columns, e.g. (1|possible value are ", :type => String
    opt :numc, "Number of data columns", :type => Integer, :short => 'c'
    opt :debug, "debug"
    opt :title, "Title", :type=> String, :short => 't'
    opt :font, "Font", :type => String, :short => 'f'
    opt :time, "Time format for time series data, strftime expression", :type => String
    opt :ranges, "A list comma separated pairs of gnuplot range-expressions, e.g. xrange [-10:10], yrange[0:40], y2range [0:1]", type:String
    opt :extra_header, "Extra commands to be put in the header of the gnuplot file", :type => String
end

title = @opts[:title] || ""

if (!find_executable 'gnuplot')
    STDERR.puts("This utility depends on gnuplot. Please install gnuplot using your favourite package manager.")
    exit(1)
end

# TODO I do want to be streamed!
input = `cat`
File.open(DATA_FILE_NAME, "w"){|f| f.write(input)}

numc_input=input.split(/\n/)[0].split(/\s+/).length - 1
puts "Detected numc y-columns #{numc_input}"


numc = @opts[:numc] || numc_input

axis_labels = (@opts[:axis_labels] || " | ").split("|")

legends = (@opts[:legends] ? @opts[:legends].strip().split(/,/) : (1..(numc)).map{|x| ""}).map{|x| x.strip}

axes = @opts[:axes] ? @opts[:axes].split("|") : [1] * legends.length

plot_styles =  @opts[:plot_styles] ? @opts[:plot_styles].strip().split(/,/)  : [ "points" ] * legends.length

ranges = @opts[:ranges] ? @opts[:ranges].split(",").map{ |r| "set #{r}"}.join("\n") : ""

font = @opts[:font] || "Futura"
font_size = "12"
using_list = legends.zip((2..100).to_a, axes, plot_styles).
    map{|text, index, yaxis, plot_style|
        "'#{DATA_FILE_NAME}' using 1:#{index} title \"#{text}\" with #{plot_style} ls #{index-1} axes x1y#{yaxis}"
    }.join(", ")

extra_header = @opts[:extra_header] || ""

if (@opts[:outfile])
    filename = @opts[:outfile]
    extension = filename.gsub(/[^.]*\./,"")
    if (extension == "png")
        terminal=<<EOF
            set term pngcairo font '#{font},#{font_size}' transparent size 1200,800
            set output '#{filename}'

EOF
    elsif (extension == "eps")
        terminal=<<EOF
            set term epscairo size 1200,800 font '#{font},#{font_size}'
            set output '#{filename}'
EOF
    elsif (extension == "pdf")
        terminal=<<EOF
            set term pdfcairo size 22cm,14cm font '#{font},#{font_size}'
            set output '#{filename}'
EOF
    elsif (extension == "svg")
        terminal=<<EOF
            set term svg size 1200,800 font '#{font},#{font_size}'
            set output '#{filename}'
EOF
    else
        throw "Unknown output format '.#{extension}'."
    end


end


if (@opts[:time])
    timeExpr=@opts[:time]
    time=<<EOF
set xdata time
set timefmt "#{timeExpr}"
set format x "%H:%M"
set autoscale x
EOF
else
    time=""
end


script = <<EOF
#{terminal}
#{axis_labels.map{ | axis | pair=axis.split(":"); "set #{pair[0]}label '#{pair[1]}';"}.join("\n")}
set key outside
set key left top
#set offsets 1, 1, 1, 0
set style line 1 lc rgb '#cc0000' pt 4 ps 1 lt 1 lw 3 # --- red
set style line 2 lc rgb '#4e9a06' pt 6 ps 1 lt 1 lw 3 # --- green
set style line 3 lc rgb '#3465a4' pt 7 ps 1 lt 1 lw 3 # --- blue
set style line 4 lc rgb '#f57900' pt 8 ps 1 lt 1 lw 3 # --- orange
set style line 5 lc rgb '#edd400' pt 9 ps 1 lt 1 lw 3 # --- butter
set style line 11 lc rgb '#808080' lt 1
set border 3 back ls 11
set tics nomirror
set style line 12 lc rgb '#808080' lt 0 lw 1
set grid back ls 12
set y2tics
#{extra_header}

#{ranges}

set title "#{title}"
#{time}
plot #{using_list}

EOF


puts "data file " + DATA_FILE_NAME
puts "plot file " + PLOT_FILE_NAME



File.open(PLOT_FILE_NAME, "w"){|f| f.write(script)}

persistent_opt = @opts[:outfile]?"":"-p"

`gnuplot #{persistent_opt} #{PLOT_FILE_NAME}`
